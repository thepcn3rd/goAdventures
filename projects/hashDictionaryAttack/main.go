package main

import (
	"bufio"
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"flag"
	"fmt"
	"os"
	"sync"
)

// Original code generated by ChatGPT on 8/2/2023
// Added the ability to return the word identified with the matching hash
// Added flags to be able to specify the hash and the wordlist
// Added the capability to hash a wordlist for MD5, SHA1, SHA256 and SHA512
// Added a flag to specify the hashtype
// Fixed the display of the flags

// To do:
// 1.

// Compile file for linux
/*
GOOS=linux GOARCH=amd64 go build -o hashDictionaryAttack.bin -ldflags "-w -s" main.go
*/

func main() {

	hashPtr := flag.String("hash", "", "Specify hash to test against wordlist")
	hashTypePtr := flag.String("t", "", "Sprecify the hash to calculate (md5, sha1, sha256, sha512)")
	wordListPtr := flag.String("w", "wordlist.txt", "Specify wordlist to read")
	flag.Parse()
	//wordlist = *wordListPtr

	if *hashPtr == "" || *hashTypePtr == "" {
		fmt.Print("\nA hash needs to be specified as a parameter")
		fmt.Print("\nhashDictionaryAttack.bin -t sha1 -hash 5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8 -w wordlist.txt")
		flag.Usage()
		fmt.Print("\n\n")
		os.Exit(1)
	}

	// Open the wordlist file
	//file, err := os.Open("wordlist.txt")
	file, err := os.Open(*wordListPtr)
	if err != nil {
		fmt.Println("Error opening wordlist file:", err)
		return
	}
	defer file.Close()

	// Create a channel to communicate the results back to the go routine
	results := make(chan string, 1000)

	// Create a wait group to synchronize goroutines
	var wg sync.WaitGroup

	// Start processing the wordlist concurrently
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		word := scanner.Text()

		// Increment the wait group counter
		wg.Add(1)

		// Start a goroutine to calculate the hash for the current word
		go calculateHash(word, results, &wg, *hashPtr, *hashTypePtr)
	}

	// Start a goroutine to close the results channel once all goroutines finish
	go func() {
		wg.Wait()
		close(results)
	}()

	// Read the results from the channel and print them
	for resultString := range results {

		fmt.Println("\nResults:", resultString)

	}
}

func calculateHash(word string, results chan<- string, wg *sync.WaitGroup, hash string, hashType string) {
	// Decrement the wait group counter when the function finishes
	defer wg.Done()
	var hashBytes []byte
	if hashType == "sha1" {
		sha1Hash := sha1.New()
		sha1Hash.Write([]byte(word))
		hashBytes = sha1Hash.Sum(nil)
	} else if hashType == "sha256" {
		sha256Hash := sha256.New()
		sha256Hash.Write([]byte(word))
		hashBytes = sha256Hash.Sum(nil)
	} else if hashType == "sha512" {
		sha512Hash := sha512.New()
		sha512Hash.Write([]byte(word))
		hashBytes = sha512Hash.Sum(nil)
	} else if hashType == "md5" {
		md5Hash := md5.New()
		md5Hash.Write([]byte(word))
		hashBytes = md5Hash.Sum(nil)
	} else {
		fmt.Print("\nUnsupported Hash Type Specified")
		os.Exit(0)
	}
	// Convert the raw bytes to a hexadecimal string
	hashString := hex.EncodeToString(hashBytes[:])
	resultsString := word + ":" + hashString
	// Send the hash result back to the main goroutine through the channel
	if hashString == hash {
		results <- resultsString
	}
}
